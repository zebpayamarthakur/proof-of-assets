// Required libraries
const bitcoinjs = require('bitcoinjs-lib'),
  bitcoinjsMessage = require('bitcoinjs-message'),
  axios = require('axios'),
  pLimit = require('p-limit');
let bitcoinjsNetwork = bitcoinjs.networks.bitcoin,
  networkEnv = 'mainnet';

//
// Sign messsage with private key
//
function sign_all (private_keys, message, blockhash, currency) {
  currency = currency || 'BTC';
  if(!Array.isArray(private_keys))
    throw new Error('private_keys must be an array');

  const res = { message: message, blockhash: blockhash, currency: currency, signatures: [] };
  message = (blockhash) ? blockhash + '|' + message : message;

  // sign message with each private key
  private_keys.forEach(function (priv) {
    const keyPair = bitcoinjs.ECPair.fromWIF(priv);
    const privateKey = keyPair.privateKey;
    const addr = bitcoinjs.payments.p2pkh({pubkey: keyPair.publicKey, network: bitcoinjsNetwork}).address; // get address from public key
    const sig = bitcoinjsMessage.sign(message, privateKey, keyPair.compressed).toString('hex'); // sign message

    // push signature & address to response signatures array
    res.signatures.push({
      address: addr,
      signature: sig
    });
  });

  return res;
}

//
// verify single message signature with bitcoinjs-message library
//
function verify_signature (message, addr, sig) {
  const res = bitcoinjsMessage.verify(message, addr, sig);

  return res;
}

//
// verify multiple signatures
//
function verify_signatures (obj) {
  const message = obj.message;
  
  //
  // For Multisig - Only if redeem script present in DB
  //
  if(obj.redeemScript) {
    const reqSigs = obj.reqSigs;
    const addressArray = obj.addressArray;
    let validSignCount = 0;

    // loop through each signature to verify
    for (let info of obj.signatures) {
      // convert signatuere from hex to buffer
      const signature = Buffer.from(info.signature, 'hex');

      // verify signature & check whether address is present in address array(generated by decoding redeem script)
      // increment signature count only if verification is successful
      if (verify_signature(message, info.address, signature) && addressArray.indexOf(info.address) !== -1) validSignCount++;
    }

    // In case of Multisig, check whether required signatures are found or not
    // if not found then return false
    // eg. In case of 3 out of 6 multisig address, minimum 3 signatures verification required
    if(validSignCount >= reqSigs) return true;
    else return false;
  }
  //
  // Check for each signature in array, don't check for required signatures
  //
  else {
    // loop through each signature to verify
    for (let info of obj.signatures) {
      // convert signatuere from hex to buffer
      const signature = Buffer.from(info.signature, 'hex');

      // verify each signature, if found not valid return false directly
      if (!verify_signature(message, info.address, signature)) return false;
    }

    return true;
  }
}

//
// decode redeem script with coinjs 
//
function decode_redeem_script(redeemScript) {
  if(!redeemScript) return false;

  // now decode redeem script with the help of coinjs
  // https://coinb.in/#verify
  // https://github.com/OutCast3k/coinbin/
  const coinjsScript = coinjs.script();
  const decodeScriptResopnse = coinjsScript.decodeRedeemScript(redeemScript);
  if(!decodeScriptResopnse) return false;

  // form address array
  const pubkeysArray = decodeScriptResopnse.pubkeys;
  const addressArray = new Array();
  for(let pubkey of pubkeysArray) {
    // get address from public key
    const addr = bitcoinjs.payments.p2pkh({pubkey: Buffer.from(pubkey, 'hex'), network: bitcoinjsNetwork}).address;
    // push to address array
    addressArray.push(addr);
  }
  decodeScriptResopnse.addressArray = addressArray;

  return decodeScriptResopnse;
}

function get_addresses (obj) {
  var addresses = [];
  // remove duplicates. see http://stackoverflow.com/a/14740171/96855
  var dups = {};
  obj.signatures.forEach(function (hash) {
    if (dups[hash.address]) return;
    dups[hash.address] = true;
    addresses.push(hash.address);
  });
  return addresses;
}

// Get address balance using blockchain.info or blockcypher API
function get_balance (address, blockhash, isMultisig) {
  // blockcypher api url for btc
  let apiBaseUrl = 'https://api.blockcypher.com/v1/btc/';
  // for testnet
  if(networkEnv === 'testnet') {
    apiBaseUrl += 'test3';
  }
  // for mainnet
  else {
    apiBaseUrl += 'main';
  }

  return new Promise(function(resolve, reject) {
    //
    // For multisig address - get balance for only one address i.e. multisig address
    //
    if(isMultisig) {
      if(!address) return reject('Address empty');
      if(!blockhash) return reject('Blockhash empty');

      // Get block height from block hash
      const getBlockApiUrl = `${apiBaseUrl}/blocks/${blockhash}?limit=1`;
      axios({url: getBlockApiUrl, method: 'get'})
        .then(function (getBlockResponse) {
          // check errors
          if(!getBlockResponse || getBlockResponse.status !== 200 || !getBlockResponse.data || Object.keys(getBlockResponse.data).length === 0 || !getBlockResponse.data.height) {
            return Promise.reject('Get block api failed');
          }
          
          // now get balance
          const blockHeight = getBlockResponse.data.height;
          const getBalanceApiUrl = `${apiBaseUrl}/addrs/${address}/balance?before=${blockHeight}`;
          return axios({url: getBalanceApiUrl, method: 'get'});
        })
        .then(function (getBalanceResponse) {
          // check errors
          if(!getBalanceResponse || getBalanceResponse.status !== 200 || !getBalanceResponse.data || Object.keys(getBalanceResponse.data).length === 0 || !getBalanceResponse.data.hasOwnProperty('balance')) {
            return Promise.reject('Get balance api failed');
          }

          // send response back in btc
          resolve(getBalanceResponse.data.balance / 1e8);
        })
        .catch(function (error) {
          reject(error);
        });
    }
    //
    // Not multisig then get balance for each address
    //
    else {
      // set concurrent request
      const parallelOps = 5;
      const promiseAllLimit = pLimit(parallelOps);

      // form promise request array
      const balanceApiReqPromise = address.map(function(value) {
        const getBalanceApiUrl = `${apiBaseUrl}/addrs/${value}/balance?confirmations=6`;
        return promiseAllLimit(() => axios({url: getBalanceApiUrl, method: 'get'}));
      });

      Promise.all(balanceApiReqPromise)
        .then(function (allAddressBalanceRespData) {
          // check errors
          if(!allAddressBalanceRespData || allAddressBalanceRespData.length === 0) {
            return Promise.reject('Get balance api failed');
          }

          // loop through & calculate balance
          let totalBalance = 0;
          for(let resp of allAddressBalanceRespData) {
            totalBalance += resp.data.balance || 0;
          }

          // send response back in btc
          resolve(totalBalance / 1e8);
        })
        .catch(function (error) {
          reject(error);
        });
    }
  });
}

// set bitcoin network
function set_network(network) {
  // for testnet
  if(network === 'testnet') {
    bitcoinjsNetwork = bitcoinjs.networks.testnet;
  }
  else {
    bitcoinjsNetwork = bitcoinjs.networks.bitcoin;
  }

  // set network environment string also
  networkEnv = network;
}

module.exports.signAll = sign_all;
module.exports.verifySignatures = verify_signatures;
module.exports.getBalance = get_balance;
module.exports.getAddresses = get_addresses;
module.exports.decodeRedeemScript = decode_redeem_script;
module.exports.setNetwork = set_network;